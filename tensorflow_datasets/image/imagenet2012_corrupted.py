# coding=utf-8
# Copyright 2019 The TensorFlow Datasets Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Corrupted ImageNet2012 dataset.

Apply common corruptions to the validation images in ImageNet2012 dataset.
"""
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
import numpy as np
from tensorflow_datasets.core import api_utils
from tensorflow_datasets.image import corruptions
import tensorflow_datasets.image.imagenet as imagenet_dataset
import tensorflow_datasets.public_api as tfds

_DESCRIPTION = """\
Imagenet2012Corrupted is a dataset generated by adding common corruptions to the
ImageNet dataset. In the original paper, there are 15 different corruptions,
and each has 5 levels of severity. In this dataset, we implement 12 out of the
15 corruptions, including Gaussian noise, shot noise, impulse_noise,
defocus blur, frosted glass blur, zoom blur, fog, brightness, contrast, elastic,
pixelate, and jpeg compression.
"""

_CITATION = """\
@inproceedings{
hendrycks2018benchmarking,
title={Benchmarking Neural Network Robustness to Common Corruptions and Perturbations},
author={Dan Hendrycks and Thomas Dietterich},
booktitle={International Conference on Learning Representations},
year={2019},
url={https://openreview.net/forum?id=HJz6tiCqYm},
}
"""

_LABELS_FNAME = 'image/imagenet2012_labels.txt'

# This file contains the validation labels, in the alphabetic order of
# corresponding image names (and not in the order they have been added to the
# tar file).
_VALIDATION_LABELS_FNAME = 'image/imagenet2012_validation_labels.txt'

TYPE_LIST = [
    'gaussian_noise', 'shot_noise', 'impulse_noise', 'defocus_blur',
    'frosted_glass_blur', 'zoom_blur', 'fog', 'brightness', 'contrast',
    'elastic', 'pixelate', 'jpeg_compression'
]


class Imagenet2012CorruptedConfig(tfds.core.BuilderConfig):
  """BuilderConfig for Imagenet2012Corrupted."""

  @api_utils.disallow_positional_args
  def __init__(self, corruption_type=None, severity=1, **kwargs):
    """BuilderConfig for Imagenet2012Corrupted.

    Args:
      corruption_type: string, must be one of the items in TYPE_LIST.
      severity: integer, bewteen 1 and 5.
      **kwargs: keyword arguments forwarded to super.
    """
    super(Imagenet2012CorruptedConfig, self).__init__(**kwargs)
    self.corruption_type = corruption_type
    self.severity = severity


def _make_builder_configs():
  """Construct a list of BuilderConfigs.

  Construct a list of 60 Imagenet2012CorruptedConfig objects, corresponding to
  the 12 corruption types, with each type having 5 severities.

  Returns:
    A list of 60 Imagenet2012CorruptedConfig objects.
  """
  config_list = []
  for each_corruption in TYPE_LIST:
    for each_severity in range(1, 6):
      name_str = each_corruption + '_' + str(each_severity)
      version_str = '0.0.1'
      description_str = 'corruption type = ' + each_corruption + ', severity = '
      description_str += str(each_severity)
      config_list.append(
          Imagenet2012CorruptedConfig(
              name=name_str,
              version=version_str,
              description=description_str,
              corruption_type=each_corruption,
              severity=each_severity,
          ))
  return config_list


class Imagenet2012Corrupted(imagenet_dataset.Imagenet2012):
  """Corrupted ImageNet2012 dataset.

  Usage:
  Users need to first specify two directories: manual_dir and data_dir.
  manual_dir is the directory where the uncorrupted raw imagenet data is stored.
  data_dir is the directory where the generated tf records are stored.
  The validation images in data_dir is alreay corrupted.
  There should be a folder named 'imagenet2012_corrupted' under manual_dir, and
  the '.tar' files of the ImageNet training and validation data should be stored
  in this folder, i.e., if we have
  /path_to_raw_data/imagenet2012_corrupted/ILSVRC2012_img_train.tar
  /path_to_raw_data/imagenet2012_corrupted/ILSVRC2012_img_val.tar
  then set
  manual_dir = '/path_to_raw_data'
  Users also need to specify the corruption type and severity of the corruption.
  This is done by adding configuration info to the name of the dataset.
  The name of the dataset should be in the following format:
  name = 'imagenet2012_corrupted/TYPE_SEVERITY',
  where TYPE should be one items in the TYPE_LIST list below, and SEVERITY
  should be an integer in the range [1, 5].
  An example of loading the dataset with Gaussian noise corruption:
  ----------------------------------
  manual_dir = '/path_to_raw_data'
  data_dir = /path_to_tf_records'
  kwarg_dic = {
      'download_config': tfds.download.DownloadConfig(manual_dir=manual_dir)
  }
  corruption_type = 'gaussian_noise'
  severity = 1
  name_str = 'imagenet2012_corrupted/' + corruption_type + '_' + str(severity)
  corrupted_imagenet_data = tfds.load(
      name=name_str,
      data_dir=data_dir,
      download=True,
      download_and_prepare_kwargs=kwarg_dic)
  ----------------------------------
  Then, we get a dictionary |corrupted_imagenet_data| that contains iterators to
  the training and validation dataset (with validation images being corrupted).
  """
  BUILDER_CONFIGS = _make_builder_configs()

  def __init__(self, **kwargs):
    """Init function of Imagenet2012Corrupted class.

    Set random seed.

    Args:
      **kwargs: initialization args needed in the Imagenet2012 class.
    """
    super(Imagenet2012Corrupted, self).__init__(**kwargs)
    np.random.seed(135)
    tfds.core.lazy_imports.cv2.setRNGSeed(357)

  def _info(self):
    """Basic information of the dataset.

    Returns:
      tfds.core.DatasetInfo.
    """
    names_file = tfds.core.get_tfds_path(_LABELS_FNAME)
    return tfds.core.DatasetInfo(
        builder=self,
        description=_DESCRIPTION,
        features=tfds.features.FeaturesDict({
            'image': tfds.features.Image(),
            'label': tfds.features.ClassLabel(names_file=names_file),
            'file_name': tfds.features.Text(),  # Eg: 'n15075141_54.JPEG'
        }),
        supervised_keys=('image', 'label'),
        urls=['https://openreview.net/forum?id=HJz6tiCqYm'],
        citation=_CITATION,
    )

  def _split_generators(self, dl_manager):
    """Return the validation split of ImageNet2012.

    Args:
      dl_manager: download manager object.

    Returns:
      validation split.
    """
    return [super(Imagenet2012Corrupted, self)._split_generators(dl_manager)[1]]

  def _generate_examples_validation(self, archive, labels):
    """Generate corrupted imagenet validation data.

    Apply corruptions to the raw images according to self.corruption_type.

    Args:
      archive: an iterator for the raw dataset.
      labels: a dictionary that maps the file names to imagenet labels.

    Yields:
      dictionary with the file name, an image file objective, and label of each
      imagenet validation data.
    """
    for example in super(Imagenet2012Corrupted,
                         self)._generate_examples_validation(archive, labels):
      image_np = tfds.core.lazy_imports.pyplot.imread(example['image'], 'jpg')
      example['image'] = self._get_corrupted_example(image_np)
      yield example

  def _get_corrupted_example(self, x):
    """Return corrupted images.

    Args:
      x: numpy array, uncorrupted image.

    Returns:
      numpy array, corrupted images.
    """
    corruption_type = self.builder_config.corruption_type
    severity = self.builder_config.severity

    return {
        'gaussian_noise': corruptions.gaussian_noise,
        'shot_noise': corruptions.shot_noise,
        'impulse_noise': corruptions.impulse_noise,
        'defocus_blur': corruptions.defocus_blur,
        'frosted_glass_blur': corruptions.frosted_glass_blur,
        'zoom_blur': corruptions.zoom_blur,
        'fog': corruptions.fog,
        'brightness': corruptions.brightness,
        'contrast': corruptions.contrast,
        'elastic': corruptions.elastic,
        'pixelate': corruptions.pixelate,
        'jpeg_compression': corruptions.jpeg_compression,
    }[corruption_type](x, severity)
